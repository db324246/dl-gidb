!function(){"use strict";window.Gldb=function(){const e=e=>new Promise(((r,t)=>{e.onerror=t,e.onsuccess=e=>{r(e)},e.onupgradeneeded=e=>{r(e)}})),r=e=>null==e||""===e||!1===e;class t{static indexedDB=window.indexedDB||window.webkitIndexedDB||window.mozIndexedDB||window.msIndexedDB||null;static validateVersion=()=>{if(r(t.indexedDB))throw new Error("您的浏览器不支持 indexedDB, 请使用 chrome 等浏览器")};constructor({databaseName:e,version:n}){if(t.validateVersion(e),r(e))throw new Error("GIDB Error: databaseName is required");if("number"!=typeof n)throw new Error("GIDB Error: version's type is number and required ");this.databaseName=e,this.version=n,this.open(e,n).then((e=>{this.dataBase=e.target.result;for(let r=0,t=this.handleQueue.length;r<t;r++){const r=this.handleQueue.shift();r&&r(e)}})).catch((e=>{this.dataBase}))}handleQueue=[];differAysncHandler(e,r=!1){return new Promise(((t,n)=>{const a=a=>{const o=a.target&&a.target.transaction;if(!o)return e(t,n,a);r?e(t,n,a):o.oncomplete=function(){e(t,n,a)}};this.dataBase?a({}):this.handleQueue.push(a)}))}open(r,n){return e(t.indexedDB.open(r,n))}close(){this.dataBase&&this.dataBase.close()}createStore(e,t){const n=(n,a)=>r(e)?a(new Error("GIDB StoreName: StoreName is required")):r(t)?a(new Error("GIDB Store Options: Store options is required")):r(t.autoIncrement)&&r(t.keyPath)?a(new Error("GIDB Store Options: keyPath is required when autoIncrement is false")):(this.dataBase.objectStoreNames.contains(e)||this.dataBase.createObjectStore(e,t),void n());return this.differAysncHandler(n,!0)}deleteStore(e){const t=(t,n)=>{if(r(e))return n(new Error("GIDB StoreName: StoreName is required"));this.dataBase.objectStoreNames.contains(e)&&this.dataBase.deleteObjectStore(e),t()};return this.differAysncHandler(t,!0)}putData(t,n){const a=(a,o,i)=>{if(r(t))return o(new Error("GIDB StoreName: StoreName is required"));if(r(n))return o(new Error("GIDB Store Put: Data is required"));const s=this.dataBase.transaction([t],"readwrite").objectStore(t);if(r(s.autoIncrement)&&r(n[s.keyPath]))return o(new Error(`GIDB Store Put: Data missing key of '${s.keyPath}'`));e(s.put(n)).then(a,o)};return this.differAysncHandler(a)}getData(t,n){const a=(a,o)=>{if(r(t))return o(new Error("GIDB Store Get: storeNames is required"));if(!Array.isArray(t)||!t.length)return o(new Error("GIDB Store Get: storeNames must be of type array and of length greater than 0"));const i=this.dataBase.transaction(t,"readonly");Promise.all(t.map((r=>{const t=i.objectStore(r);return e(n?t.get(n):t.getAll())}))).then((e=>{a(e.map((e=>e.target.result)).reduce(((e,t)=>r(t)?e:Array.isArray(t)?e.concat(t):(e.push(t),e)),[]))})).catch(o)};return this.differAysncHandler(a)}deleteData(t,n){const a=(a,o)=>{if(r(t))return o(new Error("GIDB Store Delete: storeName is required"));if(r(n))return o(new Error("GIDB Store Delete: Key is required"));const i=this.dataBase.transaction([t],"readwrite").objectStore(t);e(i.delete(n)).then(a,o)};return this.differAysncHandler(a)}countStore(t){const n=(n,a)=>{if(r(t))return a(new Error("GIDB StoreName: StoreName is required"));const o=this.dataBase.transaction([t],"readonly").objectStore(t);e(o.count()).then((e=>n(e.target.result))).catch(a)};return this.differAysncHandler(n)}clearStore(t){const n=(n,a)=>{if(r(t))return a(new Error("GIDB StoreName: StoreName is required"));const o=this.dataBase.transaction([t],"readwrite").objectStore(t);e(o.clear()).then(n,a)};return this.differAysncHandler(n)}createIndex(e){const t=(t,n,a)=>{const{storeName:o,indexName:i,keyPath:s,unique:d}=e;if(r(o))return n(new Error("GIDB createIndex: StoreName is required"));if(r(i))return n(new Error("GIDB createIndex: indexName is required"));if(r(s))return n(new Error("GIDB createIndex: keyPath is required when autoIncrement is false"));const u=a.target.transaction;if(r(u))return n(new Error("GIDB createIndex: createIndex must be done in the upgraded transaction"));const c=u.objectStore(o);Array.prototype.includes.call(c.indexNames,i)||c.createIndex(i,s,{unique:!!d}),t()};return this.differAysncHandler(t,!0)}deleteIndex(e,t){const n=(n,a,o)=>{if(r(e))return a(new Error("GIDB deleteIndex: StoreName is required"));if(r(t))return a(new Error("GIDB deleteIndex: indexName is required"));const i=o.target.transaction;if(r(i))return a(new Error("GIDB deleteIndex: deleteIndex must be done in the upgraded transaction"));const s=i.objectStore(e);Array.prototype.includes.call(s.indexNames,t)&&s.deleteIndex(t),n()};return this.differAysncHandler(n,!0)}indexStoreGetter(t,n,a){const o=(o,i,s)=>{if(r(t))return i(new Error("GIDB indexStoreGetter: StoreName is required"));if(r(n))return i(new Error("GIDB indexStoreGetter: indexName is required"));if(r(a))return i(new Error("GIDB indexStoreGetter: data is required when autoIncrement is false"));const d=this.dataBase.transaction([t],"readwrite").objectStore(t).index(n);e(d.unique?d.get(a):d.getAll(a)).then((e=>{o(e.target.result)})).catch(i)};return this.differAysncHandler(o,!0)}queryStorePage(e,t){const n=(n,a,o)=>{if(r(e))return a(new Error("GIDB indexStoreGetter: StoreName is required"));const i=this.dataBase.transaction([e],"readonly").objectStore(e),s=t.pageNumber||1,d=t.pageSize||10,u=[],c=(s-1)*d,l=s*d;let h=1;i.openCursor(null,"prev").onsuccess=e=>{let r=e.target.result;return r?(h>c&&h<=l&&u.push(r.value),u.length>=d?n(u):(h++,void r.continue())):n(u)}};return this.differAysncHandler(n,!0)}}return t}()}();
