!function(){"use strict";var e,r;e=window,r=function(){const e=e=>new Promise(((r,t)=>{e.onerror=t,e.onsuccess=e=>{r(e)},e.onupgradeneeded=e=>{r(e)}})),r=e=>null==e||""===e||!1===e;return class{validateVersion(){if(r(this.indexedDB))throw new Error("您的浏览器不支持 indexedDB, 请使用 chrome 等浏览器")}constructor({databaseName:e,version:t}){if(this.indexedDB=window.indexedDB||window.webkitIndexedDB||window.mozIndexedDB||window.msIndexedDB||null,this.validateVersion(e),r(e))throw new Error("GIDB Error: databaseName is required");if("number"!=typeof t)throw new Error("GIDB Error: version's type is number and required ");this.handleQueue=[],this.databaseName=e,this.version=t,this.open(e,t).then((e=>{this.dataBase=e.target.result;for(let r=0,t=this.handleQueue.length;r<t;r++){const r=this.handleQueue.shift();r&&r(e)}})).catch((e=>{this.dataBase}))}differAysncHandler(e,r=!1){return new Promise(((t,n)=>{const a=a=>{const i=a.target&&a.target.transaction;if(!i)return e(t,n,a);r?e(t,n,a):i.oncomplete=function(){e(t,n,a)}};this.dataBase?a({}):this.handleQueue.push(a)}))}open(r,t){return e(this.indexedDB.open(r,t))}close(){this.dataBase&&this.dataBase.close()}createStore(e,t){return this.differAysncHandler(((n,a)=>r(e)?a(new Error("GIDB StoreName: StoreName is required")):r(t)?a(new Error("GIDB Store Options: Store options is required")):r(t.autoIncrement)&&r(t.keyPath)?a(new Error("GIDB Store Options: keyPath is required when autoIncrement is false")):(this.dataBase.objectStoreNames.contains(e)||this.dataBase.createObjectStore(e,t),void n())),!0)}deleteStore(e){return this.differAysncHandler(((t,n)=>{if(r(e))return n(new Error("GIDB StoreName: StoreName is required"));this.dataBase.objectStoreNames.contains(e)&&this.dataBase.deleteObjectStore(e),t()}),!0)}putData(t,n){return this.differAysncHandler(((a,i,o)=>{if(r(t))return i(new Error("GIDB StoreName: StoreName is required"));if(r(n))return i(new Error("GIDB Store Put: Data is required"));const s=this.dataBase.transaction([t],"readwrite").objectStore(t);if(r(s.autoIncrement)&&r(n[s.keyPath]))return i(new Error(`GIDB Store Put: Data missing key of '${s.keyPath}'`));e(s.put(n)).then(a,i)}))}getData(t,n){return this.differAysncHandler(((a,i)=>{if(r(t))return i(new Error("GIDB Store Get: storeNames is required"));if(!Array.isArray(t)||!t.length)return i(new Error("GIDB Store Get: storeNames must be of type array and of length greater than 0"));const o=this.dataBase.transaction(t,"readonly");Promise.all(t.map((r=>{const t=o.objectStore(r);return e(n?t.get(n):t.getAll())}))).then((e=>{a(e.map((e=>e.target.result)).reduce(((e,t)=>r(t)?e:Array.isArray(t)?e.concat(t):(e.push(t),e)),[]))})).catch(i)}))}deleteData(t,n){return this.differAysncHandler(((a,i)=>{if(r(t))return i(new Error("GIDB Store Delete: storeName is required"));if(r(n))return i(new Error("GIDB Store Delete: Key is required"));const o=this.dataBase.transaction([t],"readwrite").objectStore(t);e(o.delete(n)).then(a,i)}))}countStore(t){return this.differAysncHandler(((n,a)=>{if(r(t))return a(new Error("GIDB StoreName: StoreName is required"));const i=this.dataBase.transaction([t],"readonly").objectStore(t);e(i.count()).then((e=>n(e.target.result))).catch(a)}))}clearStore(t){return this.differAysncHandler(((n,a)=>{if(r(t))return a(new Error("GIDB StoreName: StoreName is required"));const i=this.dataBase.transaction([t],"readwrite").objectStore(t);e(i.clear()).then(n,a)}))}createIndex(e){return this.differAysncHandler(((t,n,a)=>{const{storeName:i,indexName:o,keyPath:s,unique:d}=e;if(r(i))return n(new Error("GIDB createIndex: StoreName is required"));if(r(o))return n(new Error("GIDB createIndex: indexName is required"));if(r(s))return n(new Error("GIDB createIndex: keyPath is required when autoIncrement is false"));const u=a.target.transaction;if(r(u))return n(new Error("GIDB createIndex: createIndex must be done in the upgraded transaction"));const c=u.objectStore(i);Array.prototype.includes.call(c.indexNames,o)||c.createIndex(o,s,{unique:!!d}),t()}),!0)}deleteIndex(e,t){return this.differAysncHandler(((n,a,i)=>{if(r(e))return a(new Error("GIDB deleteIndex: StoreName is required"));if(r(t))return a(new Error("GIDB deleteIndex: indexName is required"));const o=i.target.transaction;if(r(o))return a(new Error("GIDB deleteIndex: deleteIndex must be done in the upgraded transaction"));const s=o.objectStore(e);Array.prototype.includes.call(s.indexNames,t)&&s.deleteIndex(t),n()}),!0)}indexStoreGetter(t,n,a){return this.differAysncHandler(((i,o,s)=>{if(r(t))return o(new Error("GIDB indexStoreGetter: StoreName is required"));if(r(n))return o(new Error("GIDB indexStoreGetter: indexName is required"));if(r(a))return o(new Error("GIDB indexStoreGetter: data is required when autoIncrement is false"));const d=this.dataBase.transaction([t],"readwrite").objectStore(t).index(n);e(d.unique?d.get(a):d.getAll(a)).then((e=>{i(e.target.result)})).catch(o)}),!0)}queryStorePage(e,t){return this.differAysncHandler(((n,a,i)=>{if(r(e))return a(new Error("GIDB indexStoreGetter: StoreName is required"));const o=this.dataBase.transaction([e],"readonly").objectStore(e),s=t.pageNumber||1,d=t.pageSize||10,u=[],c=(s-1)*d,h=s*d;let l=1;o.openCursor(null,"prev").onsuccess=e=>{let r=e.target.result;return r?(l>c&&l<=h&&u.push(r.value),u.length>=d?n(u):(l++,void r.continue())):n(u)}}),!0)}}},"object"==typeof exports?module.exports=exports=r():"function"==typeof define&&define.amd?define([],r):e.Gldb=r()}();
